package recommendation;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import javax.xml.bind.JAXBException;

import org.dmg.pmml.FieldName;
import org.jpmml.evaluator.Evaluator;
import org.jpmml.evaluator.FieldValue;
import org.jpmml.evaluator.InputField;
import org.jpmml.evaluator.LoadingModelEvaluatorBuilder;
import org.xml.sax.SAXException;

import db.MySQLConnection;

public class Model {
	static private Evaluator evaluator;
	static private MySQLConnection connection;
	static List<? extends InputField> inputFields;
	static Map<FieldName, FieldValue> arguments;
	
	public Model() {
	}
	
	public static void main(String[] args) {
		try {
			evaluator = new LoadingModelEvaluatorBuilder().load(new File("svm_test.pmml")).build();
		} catch (IOException | SAXException | JAXBException e) {
			e.printStackTrace();
		}
	}
	
	public List<Integer> runModel(Set<String> userFridge) {
		connection = new MySQLConnection();
		// get top N frequent ingredients
		HashMap<String, Integer> map = connection.getIngredientFreq();
		List<String> freqWords = freqWords(map, 10);
//		List<String> freqWords = new ArrayList<>();
//		freqWords.add("olive oil");
//		freqWords.add("salt");
//		freqWords.add("garlic");
//		freqWords.add("lemon juice");
//		freqWords.add("garlic cloves");
//		freqWords.add("salt and pepper");
//		freqWords.add("anchovy");
//		freqWords.add("kosher salt");
//		freqWords.add("shrimp");
//		freqWords.add("black pepper");
		System.out.println("done get freWords");

		// Building a model/ evaluator from a PMML file
			System.out.println("done load svm model");
			
			// transform userFridge for model
			List<Double> hasIngre = getHasIngreList(userFridge, freqWords);
			connection.close();
			System.out.println("done load user fridge");
			
			// prepare argument for model
			inputFields = evaluator.getInputFields();
//			System.out.println("Input fields: " + inputFields);
			arguments = setUpArguments(inputFields, hasIngre);
			System.out.println("done set up arguments");

			// Evaluating the model with known-good arguments
			Map<FieldName, ?> results = evaluator.evaluate(arguments);
			System.out.println("done evaluate model");
			
			// get top N matched itemIds
			List<Integer> topNMatchItemId = getTopNMatch(results, 5);
//			List<Integer> topNMatchItemId = new ArrayList<>();
//			topNMatchItemId.add(1);
//			topNMatchItemId.add(2);
//			topNMatchItemId.add(3);
//			topNMatchItemId.add(4);
//			topNMatchItemId.add(5);
			System.out.println("done find top N matches");
			return topNMatchItemId;
	}
	
	public List<Integer> getTopNMatch(Map<FieldName, ?> results, int N) {
		String str = results.toString();
		str = str.substring(str.indexOf("[") + 1);
		str = str.substring(0, str.indexOf("]"));
		String[] parts = str.split(", ");
		HashMap<Integer, Double> mapProb = new HashMap<>();
		for (String s : parts ) {
			String[] parts2 = s.split("=");
			mapProb.put(Integer.parseInt(parts2[0]), Double.parseDouble(parts2[1]));
			}
		
		List<Integer> topNMatch = mapProb.entrySet().stream()
				.sorted(Collections.reverseOrder(Map.Entry.comparingByValue())).limit(N)
				.map(Map.Entry::getKey)
				.collect(Collectors.toList());
		return topNMatch;
	}
	
	public Map<FieldName, FieldValue> setUpArguments(List<? extends InputField> inputFields, List<Double> hasIngre) {
		Map<String, Double> inputRecord = new HashMap<>();
		for (int i = 0; i < inputFields.size(); i++) {
			inputRecord.put(inputFields.get(i).getFieldName().toString(), hasIngre.get(i));
		}

		Map<FieldName, FieldValue> arguments = new LinkedHashMap<>();

		// Mapping the record field-by-field from data source schema to PMML schema
		for (InputField inputField : inputFields) {
			FieldName inputName = inputField.getName();
			Object rawValue = inputRecord.get(inputName.getValue());

			// Transforming an arbitrary user-supplied value to a known-good PMML value
			FieldValue inputValue = inputField.prepare(rawValue);
			arguments.put(inputName, inputValue);
		}
		return arguments;
	}
	
	public List<Double> getHasIngreList (Set<String> userFridge, List<String> freqWords) {
		List<Double> hasIngre = new ArrayList<>();
		for (int i = 0; i < freqWords.size(); i++) {
			for (String ingre: freqWords) {
				if (userFridge.contains(ingre)) {
					hasIngre.add(1.0);
				} else {
					hasIngre.add(0.0);
				}
			}
		}
		return hasIngre;
	}

	public static int calculateTopN(HashMap<String, Integer> map) {
		int total = map.keySet().size();
		int topN = total * 9 / 10;
//		System.out.println("total ingredients: " + total + "\n");
//		System.out.println("top n = :" + topN + "\n");
		return topN;
	}

	// helper method to get top N most frequent ingredients
	public static List<String> freqWords(HashMap<String, Integer> map, int topN) {
		// sort the HashMap by frequency and get top N frequent key-value pair
		List<String> freqWords = map.entrySet().stream()
				.sorted(Collections.reverseOrder(Map.Entry.comparingByValue())).limit(topN)
				.map(Map.Entry::getKey)
				.collect(Collectors.toList());
		
		return freqWords;
	}
	
	
}