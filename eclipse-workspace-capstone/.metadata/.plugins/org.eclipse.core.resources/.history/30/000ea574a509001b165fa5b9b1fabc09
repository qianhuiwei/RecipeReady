package recommendation;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.stream.Collectors;

import javax.xml.bind.JAXBException;

import org.dmg.pmml.FieldName;
import org.dmg.pmml.PMML;
import org.jpmml.evaluator.Evaluator;
import org.jpmml.evaluator.EvaluatorUtil;
import org.jpmml.evaluator.FieldValue;
import org.jpmml.evaluator.HasProbability;
import org.jpmml.evaluator.InputField;
import org.jpmml.evaluator.LoadingModelEvaluatorBuilder;
import org.jpmml.evaluator.ModelEvaluatorFactory;
import org.jpmml.evaluator.OutputField;
import org.jpmml.evaluator.Report;
import org.jpmml.evaluator.ReportUtil;
import org.jpmml.evaluator.TargetField;
import org.jpmml.evaluator.mining.MiningModelEvaluator;
import org.xml.sax.SAXException;

import db.MySQLConnection;

public class Model {
	public static void main(String[] args) {
		MySQLConnection connection = new MySQLConnection();
		// get top N frequent ingredients
		HashMap<String, Integer> map = connection.getIngredientFreq();
		Set<String> freqWords = freqWords(map, 10);

		// Building a model/ evaluator from a PMML file
		try {
			Evaluator evaluator = new LoadingModelEvaluatorBuilder().load(new File("svm_test.pmml")).build();
//			evaluator.verify();
			List<? extends InputField> inputFields = evaluator.getInputFields();
//			System.out.println("Input fields: " + inputFields.size());
//			System.out.println("Fired Name: " + inputFields.get(0).getFieldName());

			// Printing primary result (y) field(s)
//			List<? extends TargetField> targetFields = evaluator.getTargetFields();
//			System.out.println("Target field(s): " + targetFields.size());

//			Set<String> fridge = connection.getFridge("userId");
//			List<Double> hasIngre = new ArrayList<>();
//			for (int i = 0; i < freqWords.size(); i++) {
//				for (String ingre: freqWords) {
//					if (fridge.contains(ingre)) {
//						hasIngre.add(1.0);
//					} else {
//						hasIngre.add(0.0);
//					}
//				}
//			}

			List<Double> hasIngre = new ArrayList<>();
			hasIngre.add(1.0);
			hasIngre.add(0.0);
			hasIngre.add(0.0);
			hasIngre.add(0.0);
			hasIngre.add(1.0);
			hasIngre.add(0.0);
			hasIngre.add(0.0);
			hasIngre.add(0.0);
			hasIngre.add(1.0);
			hasIngre.add(0.0);

			connection.close();
			Map<String, Double> inputRecord = new HashMap<>();
			for (int i = 0; i < inputFields.size(); i++) {
				inputRecord.put(inputFields.get(i).getFieldName().toString(), hasIngre.get(i));
			}

			Map<FieldName, FieldValue> arguments = new LinkedHashMap<>();

			// Mapping the record field-by-field from data source schema to PMML schema
			for (InputField inputField : inputFields) {
				FieldName inputName = inputField.getName();
				Object rawValue = inputRecord.get(inputName.getValue());

				// Transforming an arbitrary user-supplied value to a known-good PMML value
				FieldValue inputValue = inputField.prepare(rawValue);
				arguments.put(inputName, inputValue);
			}

			// Evaluating the model with known-good arguments
			Map<FieldName, ?> results = evaluator.evaluate(arguments);
			String str = results.toString();
			str = str.substring(str.indexOf("[") + 1);
			str = str.substring(0, str.indexOf("]"));
			String[] parts = str.split(",");
			for (String s : parts ) {
				System.out.println(s);
			}
			
			


		} catch (IOException | SAXException | JAXBException e) {

			e.printStackTrace();
		}

	}

	public static int calculateTopN(HashMap<String, Integer> map) {
		int total = map.keySet().size();
		int topN = total * 9 / 10;
//		System.out.println("total ingredients: " + total + "\n");
//		System.out.println("top n = :" + topN + "\n");
		return topN;
	}

	// helper method to get top N most frequent ingredients
	public static Set<String> freqWords(HashMap<String, Integer> map, int topN) {
		// sort the HashMap by frequency and get top N frequent key-value pair
		Map<String, Integer> sortedMap = map.entrySet().stream()
				.sorted(Collections.reverseOrder(Map.Entry.comparingByValue())).limit(topN)
				.collect(Collectors.toMap(Entry::getKey, Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));

		// get top N ingredient names
		Set<String> freqWords = sortedMap.keySet();
		return freqWords;
	}
}